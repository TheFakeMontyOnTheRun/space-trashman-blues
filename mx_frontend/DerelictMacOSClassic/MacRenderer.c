#include <stddef.h>#include <stdint.h>#include <string.h>#include "Common.h"#include "Enums.h"#include "FixP.h"#include "Vec.h"#include "Vec.h"#include "LoadBitmap.h"#include "CActor.h"#include "Engine.h"#include "Dungeon.h"#include "MapWithCharKey.h"#include "CTile3DProperties.h"#include "CRenderer.h"#include <stdio.h>#include <Quickdraw.h>#include <MacWindows.h>#include <Dialogs.h>#include <Menus.h>#include <ToolUtils.h>#include <Devices.h>#include <Files.h>#include <Sound.h>#include <Processes.h>#define kMBarDisplayed 128#define mApple 128#define mAppleAbout 1#define mFile 129#define mFileReset 1#define mFileQuit 2#define rUserAlert 129#define APP_NAME_STRING "\pSub Mare Imperium - Derelict"#define SCREEN_WIDTH 320#define SCREEN_HEIGHT 240struct RGBColor mPalette[256];PaletteHandle myPalette;SndChannelPtr sndChannelPtr;extern uint8_t framebuffer[320 * 200];uint8_t previousFrameState[320 * 200];/*GWorldPtr offscreenBuffer;*/extern enum ECommand mBufferedCommand;extern char* filePrefix;void soundTick(){}void playSound(const int action) {}void setupOPL2(void){}void stopSounds(void) {}//--------------------------------------------------------------------------------int tick = 0;WindowPtr mainWindowPtr;Boolean quit = 0;int lastTick = 0;int MouseState = 0;int HeldPixel = 0;const short appleM = 0;const short fileM = 1;struct BitMap backbuffer;QDGlobals qdGlobals;struct PixMap offscreenBuffer;struct Bitmap *mFont;int mCached;uint8_t lastKey = 0;//--------------------------------------------------------------------------------uint8_t getPaletteEntry(const uint32_t origin) {	uint8_t shade;	if (!(origin & 0xFF000000)) {		return TRANSPARENCY_COLOR;	}	shade = 0;	shade += (((((origin & 0x0000FF)) << 2) >> 8)) << 6;	shade += (((((origin & 0x00FF00) >> 8) << 3) >> 8)) << 3;	shade += (((((origin & 0xFF0000) >> 16) << 3) >> 8)) << 0;	return shade;}//--------------------------------------------------------------------------------Rect TMRGetBounds(){	Rect r;	#if TARGET_API_MAC_CARBON	BitMap 			theScreenBits;	GetWindowPortBounds(mainWindowPtr, &r);#else	r = qd.thePort->portRect;#endif		return r;}//--------------------------------------------------------------------------------void DrawWindow() {		Rect r = TMRGetBounds();	Rect pixelRect;	int x = 0, y = 0;	int dstY = 0;	int scaller = 0;	int even = 0;	int heightY = 1;	uint32_t offset = 0;			for (y = 0; y < 200; ++y) {		if (scaller == 4 ) {			heightY = 2;		} else {			heightY = 1;		}		for (x = 0; x < 320; ++x ) {			uint8_t pixel = framebuffer[ offset ];						if (pixel != previousFrameState[ offset ]) {				RGBForeColor(&mPalette[pixel]);				SetRect( &pixelRect, x, dstY, x + 1, dstY + heightY);				PaintRect( &pixelRect );						}			previousFrameState[ offset ] = pixel;			offset++;		}		dstY++;		scaller++;				if (scaller == 5 ) {			scaller = 0;			dstY++;		}	}}//--------------------------------------------------------------------------------void DoCommand(long mResult){	short theItem;	short theMenu;	Str255		daName;	short		daRefNum;		theItem = LoWord(mResult);	theMenu = HiWord(mResult);		switch (theMenu) {		case mApple: {			if (theItem == mAppleAbout) {				Alert(rUserAlert, nil);			} else {				/* all non-About items in this menu are Desk Accessories */				/* type Str255 is an array in MPW 3 */				GetMenuItemText(GetMenuHandle(mApple), theItem, daName);				daRefNum = OpenDeskAcc(daName);			}			break;		}		case mFile: {			switch (theItem) {				case mFileReset://					BPReset();					break;									case mFileQuit:					quit = 1;					isRunning = 0;					break;									default:					break;			}			break;		}		default:			break;	}		HiliteMenu(0);}//--------------------------------------------------------------------------------void handleSystemEvents() {	EventRecord    theEvent;	WindowPtr whichWindow;	Rect windRect;	Boolean        gotevent = 0;		if (!quit) {		SystemTask();		tick++;		soundTick();				{			KeyMap keys;								GetKeys(keys);								switch(keys[3]) {				case 64:				lastKey = kCommandUp;				break;											case 32:				lastKey = kCommandDown;				break;											case 16:				lastKey = kCommandRight;				break;											case 8:				lastKey = kCommandLeft;				break;											case 268435456: //enter				lastKey = kCommandFire1;				break;											case 512: //space				lastKey = kCommandFire2;				break;			}									switch(keys[1]) {						case 256: //tab				lastKey = kCommandFire3;				break;											case 268435456: //enter				lastKey = kCommandFire1;				break;											case 512: //space				lastKey = kCommandFire2;				break;			}							if (keys[3] == 0 && keys[1] == 0 && lastKey != 0) {				mBufferedCommand = lastKey;				visibilityCached = false;				lastKey = 0;			}		}		if (GetNextEvent(everyEvent, &theEvent)) {			switch (theEvent.what) {								case mouseUp: {					MouseState = 0;					break;				}								case mouseDown: {					switch (FindWindow(theEvent.where, &whichWindow)) {							// Click happens in a Desk Accessory						case inSysWindow:  {							SystemClick(&theEvent, whichWindow);							break;						}						case inMenuBar: {							DoCommand(MenuSelect(theEvent.where));							break;						}						case inDrag: {							windRect = qdGlobals.screenBits.bounds;							DragWindow(whichWindow, theEvent.where, &windRect);							break;						}						case inContent: {							if (whichWindow != FrontWindow()) {								SelectWindow(whichWindow);							} else {								MouseState = 1;							}														break;						}													default:							break;					}					break;				}									case autoKey:				case keyDown: {									char theChar = (theEvent.message&charCodeMask);										if (theEvent.modifiers&cmdKey) {						DoCommand(MenuKey(theChar));											}															switch (theChar) {						case 's':						mBufferedCommand = kCommandStrafeLeft;						visibilityCached = false;						break;						case 'd':						mBufferedCommand = kCommandStrafeRight;						visibilityCached = false;						break;												case 'q':						mBufferedCommand = kCommandBack;						break;						case 'z':						mBufferedCommand = kCommandFire1;						visibilityCached = false;						break;													case 'x':						mBufferedCommand = kCommandFire2;						visibilityCached = false;						break;							case 'c':						mBufferedCommand = kCommandFire3;						visibilityCached = false;						break;											}						break;				}								case activateEvt: {					memset(&previousFrameState[0], TRANSPARENCY_COLOR, 320 * 200 );					if (theEvent.modifiers&activeFlag) {					} else {					}					break;				}								case updateEvt: {					BeginUpdate((WindowPtr)theEvent.message);										DrawWindow();					EndUpdate((WindowPtr)theEvent.message);					break;				}				default:					break;			}		}	}	}//--------------------------------------------------------------------------------void SetUpMenus() {	short i;	OSErr err;	long result;	MenuRef menu;		MenuHandle myMenus[3];	/*	myMenus[appleM] = GetMenu(mApple);*//*	AddResMenu(myMenus[appleM],'DRVR'); // System-provided Desk Accessories menu  *//*	myMenus[appleM] = GetMenu(mApple);	myMenus[fileM] = GetMenu(mFile);		for (i = 0; i < 2; i++) {		InsertMenu(myMenus[i], 0);	}*/			DrawMenuBar();}//--------------------------------------------------------------------------------void graphicsShutdown() {	ExitToShell();}//--------------------------------------------------------------------------------void flipRenderer() {	InvalRect(&qdGlobals.thePort->portRect);}//--------------------------------------------------------------------------------void clearRenderer() {	memset(&previousFrameState[0], TRANSPARENCY_COLOR, 320 * 200 );}//--------------------------------------------------------------------------------void Initialize(void) {	OSErr err;	OSErr		error;		InitGraf((Ptr) &qdGlobals.thePort);	InitFonts();		FlushEvents(everyEvent, 0);		InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();			SetUpMenus();}//--------------------------------------------------------------------------------void graphicsInit(){	int r, g, b, i;	Rect windowRect;		Initialize();		SetRect(&windowRect, 50, 50, 50+SCREEN_WIDTH, 50+SCREEN_HEIGHT);		mainWindowPtr = NewCWindow(nil, &windowRect, APP_NAME_STRING, true, noGrowDocProc, (WindowPtr)-1L, true, (long)nil);	SetPort((struct GrafPort*)GetWindowPort(mainWindowPtr));	mCached = false;    mFont = loadBitmap("font.img");    defaultFont = mFont;        myPalette = NewPalette(256, NULL, pmTolerant, 4000);    	for (r = 0; r < 256; r += 16) {		for (g = 0; g < 256; g += 8) {			for (b = 0; b < 256; b += 8) {				uint32_t pixel = 0xFF000000 + (b << 16) + (g << 8) + (r);				uint8_t paletteEntry = getPaletteEntry(pixel);				mPalette[paletteEntry].red = ((r) * 0xFFFF) / 256;				mPalette[paletteEntry].green = ((g) * 0xFFFF) / 256;				mPalette[paletteEntry].blue = ((b) * 0xFFFF) / 256;			}		}	}		for (i = 0; i < 256; ++i ) {		SetEntryColor(myPalette, i, &mPalette[i] );	}		SetPalette((WindowPtr)mainWindowPtr, myPalette, TRUE);		clearRenderer();		if (SndNewChannel(&sndChannelPtr, squareWaveSynth, 0, NULL) != noErr ) {		puts("Error initializing sound");	}}