#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <sms.h>
#include <stdio.h>
#include <msx/gfx.h>

#include "Core.h"
#include "Derelict.h"
#include "Engine3D.h"

extern struct ObjectNode *focusedItem;
extern struct ObjectNode *roomItem;
extern int accessGrantedToSafe;

void graphicsFlush();

void nextItemInHand();

void useItemInHand();

void nextItemInRoom();

void interactWithItemInRoom();

void pickOrDrop();

void dropItem();

void pickItem();

void clearGraphics();

uint8_t font[] = {
          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 // space
        , 0x10,0x38,0x38,0x10,0x10,0x00,0x10,0x00
        , 0x6c,0x6c,0x48,0x00,0x00,0x00,0x00,0x00
        , 0x00,0x28,0x7c,0x28,0x28,0x7c,0x28,0x00
        , 0x20,0x38,0x40,0x30,0x08,0x70,0x10,0x00
        , 0x64,0x64,0x08,0x10,0x20,0x4c,0x4c,0x00
        , 0x20,0x50,0x50,0x20,0x54,0x48,0x34,0x00
        , 0x30,0x30,0x20,0x00,0x00,0x00,0x00,0x00
        , 0x10,0x20,0x20,0x20,0x20,0x20,0x10,0x00
        , 0x20,0x10,0x10,0x10,0x10,0x10,0x20,0x00
        , 0x00,0x28,0x38,0x7c,0x38,0x28,0x00,0x00
        , 0x00,0x10,0x10,0x7c,0x10,0x10,0x00,0x00
        , 0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x20
        , 0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00
        , 0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00
        , 0x00,0x04,0x08,0x10,0x20,0x40,0x00,0x00 // /space - 15
        , 0x38,0x44,0x4c,0x54,0x64,0x44,0x38,0x00 // 0
        , 0x10,0x30,0x10,0x10,0x10,0x10,0x38,0x00
        , 0x38,0x44,0x04,0x18,0x20,0x40,0x7c,0x00
        , 0x38,0x44,0x04,0x38,0x04,0x44,0x38,0x00
        , 0x08,0x18,0x28,0x48,0x7c,0x08,0x08,0x00
        , 0x7c,0x40,0x40,0x78,0x04,0x44,0x38,0x00
        , 0x18,0x20,0x40,0x78,0x44,0x44,0x38,0x00
        , 0x7c,0x04,0x08,0x10,0x20,0x20,0x20,0x00
        , 0x38,0x44,0x44,0x38,0x44,0x44,0x38,0x00
        , 0x38,0x44,0x44,0x3c,0x04,0x08,0x30,0x00
        , 0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x00
        , 0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x20
        , 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00
        , 0x00,0x00,0x7c,0x00,0x00,0x7c,0x00,0x00
        , 0x20,0x10,0x08,0x04,0x08,0x10,0x20,0x00
        , 0x38,0x44,0x04,0x18,0x10,0x00,0x10,0x00
        , 0x38,0x44,0x5c,0x54,0x5c,0x40,0x38,0x00 // /0
        , 0x38,0x44,0x44,0x44,0x7c,0x44,0x44,0x00 // a
        , 0x78,0x44,0x44,0x78,0x44,0x44,0x78,0x00
        , 0x38,0x44,0x40,0x40,0x40,0x44,0x38,0x00
        , 0x78,0x44,0x44,0x44,0x44,0x44,0x78,0x00
        , 0x7c,0x40,0x40,0x78,0x40,0x40,0x7c,0x00
        , 0x7c,0x40,0x40,0x78,0x40,0x40,0x40,0x00
        , 0x38,0x44,0x40,0x5c,0x44,0x44,0x3c,0x00
        , 0x44,0x44,0x44,0x7c,0x44,0x44,0x44,0x00
        , 0x38,0x10,0x10,0x10,0x10,0x10,0x38,0x00
        , 0x04,0x04,0x04,0x04,0x44,0x44,0x38,0x00
        , 0x44,0x48,0x50,0x60,0x50,0x48,0x44,0x00
        , 0x40,0x40,0x40,0x40,0x40,0x40,0x7c,0x00
        , 0x44,0x6c,0x54,0x44,0x44,0x44,0x44,0x00
        , 0x44,0x64,0x54,0x4c,0x44,0x44,0x44,0x00
        , 0x38,0x44,0x44,0x44,0x44,0x44,0x38,0x00
        , 0x78,0x44,0x44,0x78,0x40,0x40,0x40,0x00
        , 0x38,0x44,0x44,0x44,0x54,0x48,0x34,0x00
        , 0x78,0x44,0x44,0x78,0x48,0x44,0x44,0x00
        , 0x38,0x44,0x40,0x38,0x04,0x44,0x38,0x00
        , 0x7c,0x10,0x10,0x10,0x10,0x10,0x10,0x00
        , 0x44,0x44,0x44,0x44,0x44,0x44,0x38,0x00
        , 0x44,0x44,0x44,0x44,0x44,0x28,0x10,0x00
        , 0x44,0x44,0x54,0x54,0x54,0x54,0x28,0x00
        , 0x44,0x44,0x28,0x10,0x28,0x44,0x44,0x00
        , 0x44,0x44,0x44,0x28,0x10,0x10,0x10,0x00
        , 0x78,0x08,0x10,0x20,0x40,0x40,0x78,0x00
        , 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00
        , 0x00,0x40,0x20,0x10,0x08,0x04,0x00,0x00
        , 0x38,0x08,0x08,0x08,0x08,0x08,0x38,0x00
        , 0x10,0x28,0x44,0x00,0x00,0x00,0x00,0x00
        , 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc
        , 0x30,0x30,0x10,0x00,0x00,0x00,0x00,0x00
        , 0x00,0x00,0x38,0x04,0x3c,0x44,0x3c,0x00
        , 0x40,0x40,0x78,0x44,0x44,0x44,0x78,0x00
        , 0x00,0x00,0x38,0x44,0x40,0x44,0x38,0x00
        , 0x04,0x04,0x3c,0x44,0x44,0x44,0x3c,0x00
        , 0x00,0x00,0x38,0x44,0x78,0x40,0x38,0x00
        , 0x18,0x20,0x20,0x78,0x20,0x20,0x20,0x00
        , 0x00,0x00,0x3c,0x44,0x44,0x3c,0x04,0x38
        , 0x40,0x40,0x70,0x48,0x48,0x48,0x48,0x00
        , 0x10,0x00,0x10,0x10,0x10,0x10,0x18,0x00
        , 0x08,0x00,0x18,0x08,0x08,0x08,0x48,0x30
        , 0x40,0x40,0x48,0x50,0x60,0x50,0x48,0x00
        , 0x10,0x10,0x10,0x10,0x10,0x10,0x18,0x00
        , 0x00,0x00,0x68,0x54,0x54,0x44,0x44,0x00
        , 0x00,0x00,0x70,0x48,0x48,0x48,0x48,0x00
        , 0x00,0x00,0x38,0x44,0x44,0x44,0x38,0x00
        , 0x00,0x00,0x78,0x44,0x44,0x44,0x78,0x40
        , 0x00,0x00,0x3c,0x44,0x44,0x44,0x3c,0x04
        , 0x00,0x00,0x58,0x24,0x20,0x20,0x70,0x00
        , 0x00,0x00,0x38,0x40,0x38,0x04,0x38,0x00
        , 0x00,0x20,0x78,0x20,0x20,0x28,0x10,0x00
        , 0x00,0x00,0x48,0x48,0x48,0x58,0x28,0x00
        , 0x00,0x00,0x44,0x44,0x44,0x28,0x10,0x00
        , 0x00,0x00,0x44,0x44,0x54,0x7c,0x28,0x00
        , 0x00,0x00,0x48,0x48,0x30,0x48,0x48,0x00
        , 0x00,0x00,0x48,0x48,0x48,0x38,0x10,0x60
        , 0x00,0x00,0x78,0x08,0x30,0x40,0x78,0x00
        , 0x18,0x20,0x20,0x60,0x20,0x20,0x18,0x00
        , 0x10,0x10,0x10,0x00,0x10,0x10,0x10,0x00
        , 0x30,0x08,0x08,0x0c,0x08,0x08,0x30,0x00
        , 0x28,0x50,0x00,0x00,0x00,0x00,0x00,0x00
        , 0x10,0x38,0x6c,0x44,0x44,0x7c,0x00,0x00
};

#ifndef HALF_BUFFER
#define BUFFER_SIZEX 16
#define BUFFER_SIZEY 128
#define BUFFER_RESX 128
#define BUFFER_RESY 128
#else
#define BUFFER_SIZEX 8
#define BUFFER_SIZEY 64
#define BUFFER_RESX 64
#define BUFFER_RESY 64
#endif

uint8_t buffer[BUFFER_SIZEX * BUFFER_SIZEY];

void init() {
    set_color(15, 1, 1);
    set_mode(mode_2);
    fill(MODE2_ATTR, 0xF1, MODE2_MAX);
}

char *menuItems[] = {
        "Use/Toggle current item",
        "Use current item with...",
        "Use/Pick object on the room...",
        "Drop object in hand",
        "Next item in inventory",
        "Next room item in focus",
};

void graphicsFlush();

void renderScene();

int cursorPosition = 0;

void show_text(int _x, int y, char *text) {

    uint8_t len = strlen(text);
    char *ptr = text;
    uint8_t c = 0;
    uint8_t chary = 0;
    uint8_t x = _x;

    for (; c < len && y < 64; ++c) {

        char cha = *ptr;

        if (cha == '\n') {
            ++y;
            x = _x;
            ++ptr;
            continue;
        }

        ++x;

        if (x >= 64) {
            ++y;
            x = _x;
        }

        if (cha != ' ') {
            uint8_t baseY = (y << 3);

            uint8_t *fontTop = &font[((cha - 32) << 3)];
            uint8_t baseX = (x << 3);

            for (chary = 0; chary < 8; ++chary) {
                baseY++;
                uint8_t ch = *fontTop;
                if (ch != 0) {
                    baseX += 7;
                    for (uint8_t r = 0; r < 7; ++r) {
                        if (ch & 1) {
                            set_color(2, 0, 0);pset(baseX, baseY);
                        }
                        --baseX;
                        ch >>= 1;
                    }
                }

                ++fontTop;
            }
        }
        ++ptr;
    }
}

void showMessage(const char *message) {
    int keepGoing = 1;
    clearGraphics();

    show_text(1, 1, (char *) message);
    show_text(1, 3, "Press any button to continue");

    while (keepGoing) {
        if (read_joypad1() & JOY_FIREA) {
            keepGoing = 0;
        }
    }

    clearGraphics();
    HUD_initialPaint();
}

void titleScreen() {
    int keepGoing = 1;
    clearGraphics();

    show_text(1, 1, "Space Mare Imperium:");
    show_text(1, 2, "     Derelict");
    show_text(1, 4, "by Daniel Monteiro");
    show_text(1, 6, "Press any button ");
    show_text(1, 7, "    to start");

    while (keepGoing) {
        if (read_joypad1() & JOY_FIREA) {
            keepGoing = 0;
        }
    }

    clearGraphics();
    HUD_initialPaint();
}

void performAction() {
    struct Room *room = getRoom(getPlayerRoom());

    switch (getGameStatus()) {
        case kBadVictory:
            showMessage("Victory! Too bad you didn't survive\nto tell the story\n\n\n\n\n\n");
            while (1);

        case kBadGameOver:
            showMessage("You're dead! And so are millions of\n"
                        "other people on the path of\n"
                        "destruction faulty reactor\n\n\n\n\n\n");
            while (1);

        case kGoodVictory:
            showMessage("Victory! You managed to destroy the\nship and get out alive\n\n\n\n\n\n");
            while (1);

        case kGoodGameOver:
            showMessage("You failed! While you fled the ship\n"
                        "alive, you failed to prevent the \n"
                        "worstscenario and now EVERYBODY is\n"
                        "dead (and that includes you!)\n\n\n\n\n");
            while (1);

        default:
        case kNormalGameplay:
            break;
    }

/*
char *menuItems[] = {
 0       "Use/Toggle current item",
 1       "Use current item with...",
 2       "Pick",
 3       "Drop",
 4       "Next item in inventory",
 5       "Next room item in focus",
};
*/

    switch (cursorPosition) {
        case 0:
            useObjectNamed(getItem(focusedItem->item)->description);
            break;
        case 1:
            interactWithItemInRoom();
            break;
        case 2:
            pickItem();
            break;
        case 3:
            dropItem();
            break;
        case 4:
            nextItemInHand();
            break;
        case 5:
            nextItemInRoom();
            break;
    }
}


uint8_t getKey() {
    unsigned int key = read_joypad1();

    if (key & JOY_UP) {
        return 'w';
    }

    if (key & JOY_LEFT) {
        if (key & JOY_FIREB) {
            return 'a';
        }
        return 'q';
    }


    if (key & JOY_RIGHT) {
        if (key & JOY_FIREB) {
            return 'd';
        }
        return 'e';
    }

    if (key & JOY_DOWN) {
        return 's';
    }

    if (key & JOY_FIREA) {
        performAction();
        HUD_refresh();
        return 'p';
    }

    if (key & JOY_FIREB) {
        cursorPosition = (cursorPosition + 1);

        if (cursorPosition >= 6) {
            cursorPosition = 0;
        }

        HUD_refresh();
        return 'p';
    }

    return '.';
}

void shutdownGraphics() {
}

void clearGraphics() {
    fill(MODE2_ATTR, 0xF1, MODE2_MAX);
}

void graphicsFlush() {
    uint8_t *ptr = &buffer[0];
    for (uint8_t y = 0; y < BUFFER_RESY; y += 8) {
        ptr = &buffer[ ((y) * BUFFER_SIZEX)];

        for (uint8_t x = 0; x < BUFFER_RESX;) {
            uint16_t addr = map_pixel(x, y);

            for (uint8_t r = 0; r < 8; ++r ) {
                uint8_t pixel = *ptr;
                vpoke( addr + r, pixel);
                ptr+= BUFFER_SIZEX;
            }

            //this weird order is slightly faster than what one would write initially.
            ptr-= -1 + (8 * BUFFER_SIZEX);

            x += 8;
        }

//        ptr += (BUFFER_SIZEX) * 8;
    }
    memset( &buffer[0], 0, BUFFER_SIZEX * BUFFER_SIZEY);
}

void vLine(uint8_t x0, uint8_t y0, uint8_t y1) {

#ifdef HALF_BUFFER
    x0 = x0 >> 1;
    y0 = y0 >> 1;
    y1 = y1 >> 1;
#endif

    uint8_t *ptr;
    uint8_t _y0 = y0;
    uint8_t _y1 = y1;
    uint8_t _x0 = x0;
    uint8_t offset;

    if (x0 >= BUFFER_RESX) return;

    if (y0 > y1) {
        _y0 = y1;
        _y1 = y0;
    }

    _x0 = _x0 >> 3;
    offset = (x0 & 7);
    x0 = _x0;

    ptr = &buffer[(_y0 * BUFFER_SIZEX) + x0];

    if (_y1 >= BUFFER_RESY) {
        _y1 = BUFFER_RESY - 1;
    };


    if (_y0 >= BUFFER_RESY) {
        _y0 = BUFFER_RESY - 1;
    };

    switch (offset) {
        case 0:
            for (uint8_t y = _y0; y <= _y1; ++y) {
                *ptr |= 128;
                ptr += BUFFER_SIZEX;
            }
            break;
        case 1:
            for (uint8_t y = _y0; y <= _y1; ++y) {
                *ptr |= 64;
                ptr += BUFFER_SIZEX;
            }
            break;
        case 2:
            for (uint8_t y = _y0; y <= _y1; ++y) {
                *ptr |= 32;
                ptr += BUFFER_SIZEX;
            }
            break;
        case 3:
            for (uint8_t y = _y0; y <= _y1; ++y) {
                *ptr |= 16;
                ptr += BUFFER_SIZEX;
            }
            break;
        case 4:
            for (uint8_t y = _y0; y <= _y1; ++y) {
                *ptr |= 8;
                ptr += BUFFER_SIZEX;
            }

            break;
        case 5:
            for (uint8_t y = _y0; y <= _y1; ++y) {
                *ptr |= 4;
                ptr += BUFFER_SIZEX;
            }

            break;
        case 6:
            for (uint8_t y = _y0; y <= _y1; ++y) {
                *ptr |= 2;
                ptr += BUFFER_SIZEX;
            }

            break;
        case 7:
            for (uint8_t y = _y0; y <= _y1; ++y) {
                *ptr |= 1;
                ptr += BUFFER_SIZEX;
            }

            break;
    }
}

void graphicsPut(uint8_t x, uint8_t y) {

#ifdef HALF_BUFFER
    x = x >> 1;
    y = y >> 1;
#endif

    uint8_t *ptr;
    uint8_t offset;

    if (y >= BUFFER_RESY || x >= BUFFER_RESX) return;

    offset = (x & 7);
    x = x >> 3;

    ptr = &buffer[(y * BUFFER_SIZEX) + x];

    switch (offset) {
        case 0:
            *ptr |= 128;
            break;
        case 1:
            *ptr |= 64;
            break;
        case 2:
            *ptr |= 32;
            break;
        case 3:
            *ptr |= 16;
            break;
        case 4:
            *ptr |= 8;
            break;
        case 5:
            *ptr |= 4;
            break;
        case 6:
            *ptr |= 2;
            break;
        case 7:
            *ptr |= 1;
            break;
    }
}


void HUD_initialPaint() {
    struct Room *room = getRoom(getPlayerRoom());

    draw(BUFFER_RESX, 0, BUFFER_RESX, BUFFER_RESY);
    draw(0, BUFFER_RESY, BUFFER_RESX, BUFFER_RESY);


    for (uint8_t i = 0; i < 6; ++i) {
        if (i == cursorPosition) {
            show_text(0, 16 + i, ">");
        }
        show_text(1, 16 + i, menuItems[i]);
    }
}

void HUD_refresh() {

    show_text(0, 16 + cursorPosition, ">");

    show_text(16, 0, "Object at room:");

    if (focusedItem != NULL) {
        struct Item *item = getItem(focusedItem->item);

        if (item->active) {
            show_text(16, 2, "*");
        }

        show_text(17, 2, item->description);
    }


    if (roomItem != NULL) {
        struct Item *item = getItem(roomItem->item);

        if (item->active) {
            show_text(16, 3, "*");
        }

        show_text(17, 3, item->description);
    }
}

void printSituation() {

}